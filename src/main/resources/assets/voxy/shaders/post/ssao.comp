#version 450
layout(local_size_x = 32, local_size_y = 32) in;


layout(binding = 0, rgba8) uniform writeonly restrict image2D colourTexOut;
layout(binding = 1) uniform sampler2D depthTex;
layout(binding = 2) uniform sampler2D colourTex;
layout(location = 3) uniform mat4 MVP;
layout(location = 4) uniform mat4 invMVP;
ivec2 size;

vec3 rev3d(vec3 clip) {
    vec4 view = invMVP * vec4(clip*2.0-1.0,1.0);
    return view.xyz/view.w;
}
vec4 reDeProject(vec3 pos) {
    vec4 view = MVP * vec4(pos, 1.0);
    view.xy /= view.w;
    vec2 UV = clamp(view.xy*0.5+0.5, 0.0, 1.0);

    /*
    vec4 depths = textureGather(depthTex, UV);

    vec2 dummy;
    vec2 frac = modf(UV*size, dummy);
    vec2 depths2 = mix(depths.wz, depths.xy, frac.y);
    float depth = mix(depths2.x, depths2.y, frac.x);*/

    float depth = texture(depthTex, UV).x;
    if (depth >= 0.999999f) {
        return vec4(-1.0f);
    }

    uint meta = uint(255.0f*texture(colourTex, UV).w);
    if ((meta>>6)==0) {
        return vec4(-1.0f);
    }
    view.z = depth*2.0-1.0;
    view.w = 1.0;
    view = invMVP * view;
    return vec4(view.xyz/view.w, 1.0f);
}

float computeAO(vec3 pos, float offset, vec3 normal) {
    vec4 reproData = reDeProject(pos+normal*offset);
    if (reproData.w < 0.0f) {
        return 0.0f;
    }
    vec3 repro = reproData.xyz - pos;
    float len = length(repro);
    if (len > offset+2.0f) {
        return 0.0f;
    }
    if (len <0.01f) {
        return 0.0f;
    }
    float ao = dot(repro, normal)/len;
    if (ao <0.01f) {
        return 0.0f;
    }
    return ao;
}

vec3 face2norm(uint face) {
    return vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (float(int(face)&1)*2-1);
}

void main() {
    size = imageSize(colourTexOut);//TODO: dont use imageSize as it is slow, swap for uniform
    if (any(lessThanEqual(size, gl_GlobalInvocationID.xy))) {
        return;
    }
    vec2 scale = vec2(1.0f)/size;
    vec2 point = vec2(gl_GlobalInvocationID.xy)*scale;
    point += scale*0.5f;//Offset to the center of the textile
    float depth = texture(depthTex, point).r;
    vec4 ocolour = vec4(0);
    if (depth!=0.0f && depth < 1.0f) {
        vec4 colour = texture(colourTex, point);
        if (colour == vec4(0.0f, 0.0f, 0.0f, 0.0f)) {
            ocolour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
        } else {
            uint metadata = uint(colour.w*255.0f);
            uint face = metadata&7u;
            uint lod = (metadata>>3)&7u;
            bool hasAO = (metadata>>6)!=0;
            vec3 pos = rev3d(vec3(point, depth));


            ocolour = colour;
            ocolour.w = 1.0f;

            if (hasAO) {
                vec3 worldNormal = face2norm(face);

                float OFFSET = 0.5f;

                float d = clamp(computeAO(pos, OFFSET, worldNormal),0,1);

                d = pow(d,0.15f);

                float mul = ((1.0f-d)/3.0f+(2.0f/3.0f));
                ocolour.xyz *= mul;
                //ocolour.rgb = vec3(mul);//*(worldNormal*0.5+0.5)
            }
        }
    }
    imageStore(colourTexOut, ivec2(gl_GlobalInvocationID.xy), ocolour);
}

/*
float computeAO(vec3 pos, vec3 offset, vec3 normal) {
    vec3 point = pos+offset;
    vec4 reproData = reDeProject(point);
    if (reproData.w < 0.0f) {
        return 0.0f;
    }
    float rpLen = length(reproData.xyz-point);
    if (rpLen>1.0f) {//Filter out when the depth is just way to far away
        return 0.0f;
    }
    if (rpLen<0.001f) {
        return 0.0f;
    }
    vec3 repro = reproData.xyz - pos;
    float len = length(repro);
    float ao = dot(repro, normal);
    if (ao<0.0f) {
        return 0.0f;
    }
    return rpLen;
}

vec3 face2norm(uint face) {
    return vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (float(int(face)&1)*2-1);
}

void main() {
    size = imageSize(colourTexOut);//TODO: dont use imageSize as it is slow, swap for uniform
    if (any(lessThanEqual(size, gl_GlobalInvocationID.xy))) {
        return;
    }
    vec2 scale = vec2(1.0f)/size;
    vec2 point = vec2(gl_GlobalInvocationID.xy)*scale;
    point += scale*0.5f;//Offset to the center of the textile
    float depth = texture(depthTex, point).r;
    vec4 ocolour = vec4(0);
    if (depth!=0.0f && depth < 1.0f) {
        vec4 colour = texture(colourTex, point);
        if (colour == vec4(0.0f, 0.0f, 0.0f, 0.0f)) {
            ocolour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
        } else {
            uint metadata = uint(colour.w*255.0f);
            uint face = metadata&7u;
            uint lod = (metadata>>3)&7u;
            bool hasAO = (metadata>>6)!=0;
            vec3 pos = rev3d(vec3(point, depth));


            ocolour = colour;
            ocolour.w = 1.0f;

            if (hasAO) {
                float d = 0.0f;
                //TODO: TODO: only encode the axis, then use then it as as a mask along with pos and multiply by the -sign of everything

                //vec3 worldNormal = vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (-sign(pos));

                vec3 worldNormal = face2norm(face);

                float OFFSET = 0.5f;

                //comput the other axis's
                vec3 A = face2norm((face+2)%6);
                vec3 B = face2norm((face+4)%6);

                d += clamp(computeAO(pos, OFFSET* A, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*-A, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET* B, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*-B, worldNormal),0,1)*(1f/8f);

                float ISQRT2 = 0.70710678f;
                d += clamp(computeAO(pos, OFFSET*( (A+B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*( (A-B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*((-A+B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*((-A-B)*ISQRT2), worldNormal),0,1)*(1f/8f);

                d = clamp(d,0,1);
                d = pow(d,0.2f);

                float mul = ((1-d)/2.0f+(1.0f/2.0f));
                ocolour.xyz *= mul;
                //ocolour.rgb = vec3(mul);//*(worldNormal*0.5+0.5)
            }
        }
    }
    imageStore(colourTexOut, ivec2(gl_GlobalInvocationID.xy), ocolour);
}
*/