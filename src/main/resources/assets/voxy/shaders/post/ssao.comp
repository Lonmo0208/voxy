#version 450
layout(local_size_x = 32, local_size_y = 32) in;


layout(binding = 0, rgba8) uniform writeonly restrict image2D colourTexOut;
layout(binding = 1) uniform sampler2D depthTex;
layout(binding = 2) uniform sampler2D colourTex;
layout(location = 3) uniform mat4 MVP;
layout(location = 4) uniform mat4 invMVP;


vec3 rev3d(vec3 clip) {
    vec4 view = invMVP * vec4(clip*2.0-1.0,1.0);
    return view.xyz/view.w;
}

vec4 reDeProject(vec3 pos) {
    vec4 view = MVP * vec4(pos, 1.0);
    view.xy /= view.w;
    vec2 UV = clamp(view.xy*0.5+0.5, 0.0, 1.0);
    //TODO: sample the colour texture and check if the alpha has the hasAO flag

    float depth = texture(depthTex, UV).x;
    if (depth == 1.0f) {
        return vec4(-1.0f);
    }
    uint meta = uint(255.0f*texture(colourTex, UV).w);
    if ((meta>>6)==0) {
        return vec4(-1.0f);
    }
    view.z = depth*2.0-1.0;
    view.w = 1.0;
    view = invMVP * view;
    return vec4(view.xyz/view.w, 1.0f);
}

float computeAO(vec3 pos, float testHeight, vec3 normal) {
    vec4 reproData = reDeProject(pos + normal*testHeight);
    if (reproData.w < 0.0f) {
        return 0.0f;
    }
    vec3 repro = reproData.xyz - pos;
    float len = length(repro);
    /*
    if (len<0.1*testHeight) {
        return 0.0f;
    }*/
    if (len>testHeight+2) {
        return 0.0f;
    }
    float ao = (dot(repro, normal)/len);
    if (ao<0.005f) {
        return 0.0f;
    }
    return ao;
    //return exp(ao);//return log(1/ao);
}

vec3 face2norm(uint face) {
    return vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (float(int(face)&1)*2-1);
}

void main() {
    ivec2 size = imageSize(colourTexOut);//TODO: dont use imageSize as it is slow, swap for uniform
    if (any(lessThanEqual(size, gl_GlobalInvocationID.xy))) {
        return;
    }
    vec2 scale = vec2(1.0f)/size;
    vec2 point = vec2(gl_GlobalInvocationID.xy)*scale;
    point += scale*0.5f;//Offset to the center of the textile
    float depth = texture(depthTex, point).r;
    vec4 ocolour = vec4(0);
    if (depth!=0.0f && depth < 1.0f) {
        vec4 colour = texture(colourTex, point);
        if (colour == vec4(0.0f, 0.0f, 0.0f, 0.0f)) {
            ocolour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
        } else {
            uint metadata = uint(colour.w*255.0f);
            uint face = metadata&7u;
            uint lod = (metadata>>3)&7u;
            bool hasAO = (metadata>>6)!=0;
            vec3 pos = rev3d(vec3(point, depth));


            ocolour = colour;
            ocolour.w = 1.0f;

            if (hasAO) {
                float d = 0.0f;
                //TODO: TODO: only encode the axis, then use then it as as a mask along with pos and multiply by the -sign of everything
                vec3 worldNormal = face2norm(face);
                //vec3 worldNormal = vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (-sign(pos));

                float DIST = 0.5f;
                float OFFSET = 0.5f;

                //d += clamp(computeAO(pos, DIST, worldNormal),0,1);//1
                float t = 0;
                float f = 0;
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+2)%6)), DIST, worldNormal),0,1); if (t>0) {d+=t;f+=1;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+2)%6)^1u), DIST, worldNormal),0,1); if (t>0) {d+=t;f+=1;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+4)%6)), DIST, worldNormal),0,1); if (t>0) {d+=t;f+=1;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+4)%6)^1u), DIST, worldNormal),0,1); if (t>0) {d+=t;f+=1;}


                DIST = 0.5f;
                OFFSET = 0.25f;
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+2)%6)), DIST, worldNormal),0,1); if (t>0) {d+=t*1.5f;f+=1.5;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+2)%6)^1u), DIST, worldNormal),0,1); if (t>0) {d+=t*1.5f;f+=1.5;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+4)%6)), DIST, worldNormal),0,1); if (t>0) {d+=t*1.5f;f+=1.5;}
                t = clamp(computeAO(pos+OFFSET*face2norm(((face+4)%6)^1u), DIST, worldNormal),0,1); if (t>0) {d+=t*1.5f;f+=1.5;}

                if (f>0.1) {
                    d /= f;
                }

                float mul = ((pow(1-d,1.5f))/3.0f+(2.0f/3.0f));
                ocolour.xyz *= mul;
                //ocolour.rgb = vec3(mul);
            }
        }
    }
    imageStore(colourTexOut, ivec2(gl_GlobalInvocationID.xy), ocolour);
}
