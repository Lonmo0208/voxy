#version 450
layout(local_size_x = 32, local_size_y = 32) in;


layout(binding = 0, rgba8) uniform writeonly restrict image2D colourTexOut;
layout(binding = 1) uniform sampler2D depthTex;
layout(binding = 2) uniform sampler2D colourTex;
layout(location = 3) uniform mat4 MVP;
layout(location = 4) uniform mat4 invMVP;


vec3 rev3d(vec3 clip) {
    vec4 view = invMVP * vec4(clip*2.0-1.0,1.0);
    return view.xyz/view.w;
}

vec4 reDeProject(vec3 pos) {
    vec4 view = MVP * vec4(pos, 1.0);
    view.xy /= view.w;
    vec2 UV = clamp(view.xy*0.5+0.5, 0.0, 1.0);

    float depth = texture(depthTex, UV).x;
    if (depth == 1.0f) {
        return vec4(-1.0f);
    }
    uint meta = uint(255.0f*texture(colourTex, UV).w);
    if ((meta>>6)==0) {
        return vec4(-1.0f);
    }
    view.z = depth*2.0-1.0;
    view.w = 1.0;
    view = invMVP * view;
    return vec4(view.xyz/view.w, 1.0f);
}

float computeAO(vec3 pos, vec3 offset, vec3 normal) {
    vec3 point = pos+offset;
    vec4 reproData = reDeProject(point);
    if (reproData.w < 0.0f) {
        return 0.0f;
    }
    float rpLen = length(reproData.xyz-point);
    if (rpLen>1.0f) {//Filter out when the depth is just way to far away
        return 0.0f;
    }
    if (rpLen<0.02) {
        return 0.0f;
    }
    vec3 repro = reproData.xyz - pos;
    float len = length(repro);
    float ao = dot(repro, normal);
    if (ao<0.0f) {
        return 0.0f;
    }
    return rpLen;
}

vec3 face2norm(uint face) {
    return vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (float(int(face)&1)*2-1);
}

void main() {
    ivec2 size = imageSize(colourTexOut);//TODO: dont use imageSize as it is slow, swap for uniform
    if (any(lessThanEqual(size, gl_GlobalInvocationID.xy))) {
        return;
    }
    vec2 scale = vec2(1.0f)/size;
    vec2 point = vec2(gl_GlobalInvocationID.xy)*scale;
    point += scale*0.5f;//Offset to the center of the textile
    float depth = texture(depthTex, point).r;
    vec4 ocolour = vec4(0);
    if (depth!=0.0f && depth < 1.0f) {
        vec4 colour = texture(colourTex, point);
        if (colour == vec4(0.0f, 0.0f, 0.0f, 0.0f)) {
            ocolour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
        } else {
            uint metadata = uint(colour.w*255.0f);
            uint face = metadata&7u;
            uint lod = (metadata>>3)&7u;
            bool hasAO = (metadata>>6)!=0;
            vec3 pos = rev3d(vec3(point, depth));


            ocolour = colour;
            ocolour.w = 1.0f;

            if (hasAO) {
                float d = 0.0f;
                //TODO: TODO: only encode the axis, then use then it as as a mask along with pos and multiply by the -sign of everything

                //vec3 worldNormal = vec3(uint((face>>1)==2), uint((face>>1)==0), uint((face>>1)==1)) * (-sign(pos));

                vec3 worldNormal = face2norm(face);

                float OFFSET = 0.5f;

                //comput the other axis's
                vec3 A = face2norm((face+2)%6);
                vec3 B = face2norm((face+4)%6);

                d += clamp(computeAO(pos, OFFSET* A, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*-A, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET* B, worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*-B, worldNormal),0,1)*(1f/8f);

                float ISQRT2 = 0.70710678f;
                d += clamp(computeAO(pos, OFFSET*( (A+B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*( (A-B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*((-A+B)*ISQRT2), worldNormal),0,1)*(1f/8f);
                d += clamp(computeAO(pos, OFFSET*((-A-B)*ISQRT2), worldNormal),0,1)*(1f/8f);

                if (d<0.01) {
                    d = 0.0f;
                }
                d = clamp(d,0,1);
                d = round(d*10000.0f)/10000.0f;
                d = pow(d,0.25f);

                float mul = ((1-d)/3.0f+(2.0f/3.0f));
                ocolour.xyz *= mul;
                ocolour.rgb = vec3(mul);//*(worldNormal*0.5+0.5)
                /*
                if (d>1||d<0) {
                    ocolour.rgb = vec3(1,1,0);
                }*/
            }
        }
    }
    imageStore(colourTexOut, ivec2(gl_GlobalInvocationID.xy), ocolour);
}
