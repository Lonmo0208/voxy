#version 450
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 128) in;

#define DRAW_BUFFER_BINDING 1
#define DRAW_COUNT_BUFFER_BINDING 2
#define SECTION_METADATA_BUFFER_BINDING 3
#define VISIBILITY_BUFFER_BINDING 4
#define INDIRECT_SECTION_LOOKUP_BINDING 5
#define POSITION_SCRATCH_BINDING 6
#define POSITION_SCRATCH_ACCESS writeonly

#import <voxy:lod/quad_format.glsl>
#import <voxy:lod/gl46/bindings.glsl>
#import <voxy:lod/section.glsl>
#line 11

//https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_shader_16bit_storage.txt
// adds support for uint8_t which can use for compact visibility buffer


#ifdef HAS_STATISTICS
layout(binding = STATISTICS_BUFFER_BINDING, std430) restrict buffer statisticsBuffer {
    uint visibleSectionCounts[5];
    uint quadCounts[5];
};
#endif

/*
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int  baseVertex;
    uint  baseInstance;
    */


//Note: if i want reverse indexing i need to use the index buffer offset to offset
void writeCmd(uint idx, uint instance, uint offset, uint quadCount) {
    DrawCommand cmd;
    cmd.count = quadCount * 6;
    cmd.instanceCount = 1;
    cmd.firstIndex = 0;
    cmd.baseVertex = int(offset)<<2;
    cmd.baseInstance = instance;
    cmdBuffer[idx] = cmd;
}

void main() {
    if (gl_GlobalInvocationID.x >= sectionCount) {
        return;
    }
    uint sectionId = indirectLookup[gl_GlobalInvocationID.x];
    SectionMeta meta = sectionData[sectionId];
    uint detail = extractDetail(meta);
    ivec3 ipos = extractPosition(meta);

    vec3 cornerPos = vec3(((ipos<<detail)-baseSectionPos)<<5)-cameraSubPos;


    //Note! its not with respect to the sectionId
    //
    //Check the occlusion data from this frame occlusion
    bool shouldRender = visibilityData[gl_GlobalInvocationID.x] == frameId;

    //Clear the occlusion data (not strictly? needed? i think???)
    //visibilityData[gl_GlobalInvocationID.x] = 0;

    //TODO: need to make it check that only if it was also in the frustum last frame does it apply the visibilityData check!
    // this fixes temporal coherance



    if (shouldRender) {
        #ifdef HAS_STATISTICS
        atomicAdd(visibleSectionCounts[detail], 1);
        #endif

        uint ptr = extractQuadStart(meta);
        ivec3 relative = ipos-(baseSectionPos>>detail);
        uint drawId = gl_GlobalInvocationID.x;

        positionBuffer[drawId] = uvec2(meta.posA, meta.posB);


        uint msk = 0;
        msk |= uint(((meta.cntB      &0xFFFF)!=0) && (relative.y>-1))<<0;
        msk |= uint((((meta.cntB>>16)&0xFFFF)!=0) && (relative.y<1 ))<<1;
        msk |= uint(((meta.cntC      &0xFFFF)!=0) && (relative.z>-1))<<2;
        msk |= uint((((meta.cntC>>16)&0xFFFF)!=0) && (relative.z<1 ))<<3;
        msk |= uint(((meta.cntD      &0xFFFF)!=0) && (relative.x>-1))<<4;
        msk |= uint((((meta.cntD>>16)&0xFFFF)!=0) && (relative.x<1 ))<<5;

        msk |= uint(((meta.cntA>>16)&0xFFFF)!=0)<<6;


        uint cmdPtr = atomicAdd(opaqueDrawCount, bitCount(msk));

        #ifdef HAS_STATISTICS
        uint totalQuads = 0;
        #endif

        uint count = 0;
        //Translucency
        count = meta.cntA&0xFFFF;
        if (count != 0) {
            uint translucentCommandPtr = atomicAdd(translucentDrawCount, 1) + TRANSLUCENT_OFFSET;//FIXME: dont hardcode this offset
            writeCmd(translucentCommandPtr, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //Double sided quads
        count = (meta.cntA>>16)&0xFFFF;
        if (count != 0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //Down
        count = (meta.cntB)&0xFFFF;
        if (((msk&(1u<<0))!=0)) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //Up
        count = (meta.cntB>>16)&0xFFFF;
        if ((msk&(1u<<1))!=0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //North
        count = (meta.cntC)&0xFFFF;
        if ((msk&(1u<<2))!=0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //South
        count = (meta.cntC>>16)&0xFFFF;
        if ((msk&(1u<<3))!=0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //West
        count = (meta.cntD)&0xFFFF;
        if ((msk&(1u<<4))!=0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        //East
        count = (meta.cntD>>16)&0xFFFF;
        if ((msk&(1u<<5))!=0) {
            writeCmd(cmdPtr++, drawId, ptr, count);
            #ifdef HAS_STATISTICS
            totalQuads += count;
            #endif
        }
        ptr += count;

        #ifdef HAS_STATISTICS
        atomicAdd(quadCounts[detail], totalQuads);
        #endif
    }
}